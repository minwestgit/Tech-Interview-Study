## Isolation 레벨
트랜잭션 격리수준은 동시에 여러 트랜잭션이 진행될 때 트랜잭션의 작업 결과를 여타 트랜잭션에게 어떻게 노출할 것인지를 결정한다. 스프링은 다음의 5가지 격리수준 속성을 지원한다.

- DEFAULT <br>
DEFAULT는 사용하는 데이터 액세스 기술 또는 DB 드라이버의 디폴트 설정을 따른다. 
물론 일반적으로 드라이버의 격리 수준은 DB의 격리 수준을 따르며, 대부분의 DB는 READ_COMMITED를 기본 격리수준으로 갖는다. 
하지만 일부 DB는 디폴트 값이 다른 경우도 있으므로 DEFAULT를 사용할 경우에는 드라이버와 DB의 문서를 참고해서 기본 격리수준을 확인해야 한다. MySQL만 REPEATABLE READ를 기본으로 사용한다고 한다.

- READ_UNCOMMITTED <br>
트랜잭션에서 commit 되지 않은 다른 트랜잭션에서 읽는 것을 허용한다. Dirty Read가 발생한다.
READ_UNCOMMITTED는 가장 낮은 격리수준으로써 하나의 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 그대로 노출되는 문제가 있다. 하지만 가장 빠르기 때문에 데이터의 일관성이 조금 떨어지더라도 성능을 극대화할 때 의도적으로 사용한다.
  - Dirty Read : 다른 트랜잭션에서 처리하는 작업이 완료되지 않았는데도 다른 트랜잭션에서 읽을 수 있는 현상
    
- READ_COMMITTED <br>
트랜잭션에서 commit 되어 확정된 데이터만을 읽는 것을 허용한다.
트랜잭션 A가 특정 컬럼 데이터를 변경하고 있는 중에(커밋하지 않은 상태) 트랜잭션 B가 read하면 트랜잭션 A가 변경하기 전 데이터를 읽어온다. 만약 트랜잭션 A가 데이터 변경 후 커밋하게 되면 트랜잭션 B는 변경된 데이터를 읽어온다.
READ_COMMITTED는 가장 많이 사용되는 격리수준이다. Spring은 기본적으로 DEFAULT로 지정되어 있고, DB는 일반적으로 READ_COMMITED로 되어있기 때문이다. READ_COMMITTED는 READ_UNCOMMITTED와 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 대신 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 있다. 이 때문에 처음 트랜잭션이 같은 로우를 다시 읽을 때 다른 내용이 발견될 수 있다.
  - Non-Repeatable-Read : 같은 트랜잭션에서 똑같은 SELECT 쿼리로 조회했을 때 항상 같은 결과를 가져와야 한다는 `REPETABLE READ`정합성에 어긋나는 것이다.
    
- REPEATABLE READ <br>
트랜잭션 시작 전 커밋된 내용만 조회 가능하다. MySQL InnoDB 기본 격리 수준이다. 한 트랜잭션 내에서 수 차례 SELECT 수행하더라도 동일한 값이 읽혀지는 것을 보장한다. Phantom Read 부정합이 발생할 수 있다.
REPEATABLE_READ는 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 없도록 막아준다. 하지만 새로운 로우를 추가하는 것은 막지 않는다. 따라서 SELECT로 조건에 맞는 로우를 전부 가져오는 경우 트랜잭션이 끝나기 전에 추가된 로우가 발견될 수 있다. → `PHANTOM READ`
  - PHANTOM READ : 한 트랙잭션 내 같은 쿼리를 두 번 수행 시, 없었던 레코드가 두 번째 쿼리에서 발생하는 현상. 트랜잭션 B가 데이터 읽을 때 트랜잭션 A가 데이터를 Insert하기 전과 후의 결과가 달라지는 것
    
- SERIALIZABLE <br>
모든 작업을 하나의 트랜잭션에 처리하는 것과 같은 높은 고립수준을 제공하는데, 이로인해 동시성 처리 효율은 매우 떨어진다.
SERIALIZABLE은 가장 강력한 트랜잭션 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행시켜준다. 그렇기 때문에 SERIALIZABLE은 여러 트랜잭션이 동시에 같은 테이블의 정보를 액세스할 수 없다. SERIALIZABLE은 가장 안전하지만 가장 성능이 떨어지는 격리수준이기 때문에 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용해서는 안된다.
