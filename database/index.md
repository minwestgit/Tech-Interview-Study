# Index
추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조<br>
인덱스는 범위 스캔을 하며, 키 컬럼순으로 정렬되어 있기때문에 특정값을 찾다가 해당 범위를 넘어서는 값을 만나면 멈춘다.


## 구현 자료구조
### B+tree
인덱스는 거의 B+tree로 구현된다. 데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 B-Tree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B-Tree를 인덱스에 맞게 최적화한 B+Tree가 사용된다.
<br>

**장점**
- 블럭 사이즈를 더 많이 이용할 수 있다. (Key 값에 대한 하드디스크 액세스 주소가 없기 때문)
- Leaf 노드끼리 연결 리스트로 연결되어 있어서 범위 탐색에 매우 유리하다.

**단점**
- B-Tree의 경우 최상 케이스에서는 루트에서 끝날 수 있지만, B+Tree는 무조건 leaf 노드까지 내려가봐야 한다.

#### 다른 자료구조가 아닌 B+ Tree 쓰는 이유
해시 테이블은 ‘=’은 빠르지만 부등호 연산은 어렵다. 하지만 B+Tree는 정렬된 상태이므로 부등호 연산도 가능하다. 
자식 밸런스 유지하므로 항상 탐색에 시간복잡도가 O(logN)이다. 그리고 자식노드가 여러개이므로 계속 밑으로 참조하며 탐색할 필요 없이 바로 옆 인덱스를 보면 된다. 
그러므로 데이터가 많을 경우 더 빠르다. 그냥 배열은 저장/삭제에 오래걸리므로 탈락이다. B+Tree는 탐색/저장/삭제 시간복잡도가 다 O(logN)이다.
B-Tree는 모든 데이터를 순회하려면 트리의 모든 노드를 방문해야하지만 B+Tree는 leaf node끼리 연결리스트로 연결되어 있어 더 효율적이다. 
그리고 leaf node에만 데이터를 저장하기 때문에 메모리를 더 확보할 수 있고, 하나의 node에 더 많은 포인터를 가질 수 있어 효율적이다.
