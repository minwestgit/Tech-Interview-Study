# 정렬 종류와 각각의 시간 복잡도

## 안정 정렬
중복된 값이 입력 순서와 동일하게 정렬

### 버블

첫 번째 원소부터 인접한 원소끼리 자리를 교환하는 방식. 맨 끝부터 정렬된 데이터가 쌓임.

- O(N^2) → 원소 개수가 많아질수록 성능이 저하됨

### 머지(병합)

작은 단위로 쪼갠 후 작은 단위부터 정렬해 정렬된 단위를 병합하는 방식 → 안정적 but 메모리 많이 사용됨

- O(NlogN)

### 삽입

앞에서부터 이미 정렬된 배열 부분과 비교해 자신의 위치를 찾아 삽입하는 방식 → 2번째 원소부터 마지막 원소까지 앞이랑 비교. 이미 정렬되었다면 교환 1도 안함.

- 최선 - O(N)
- 최악 - O(N^2) → 데이터 상태에 따라 편차 심함

<br>

## 불안정 정렬
중복된 값이 입력 순서와 동일하지 않게 정렬

### 힙

배열로 힙 트리 구성 후 루트 노드를 하나씩 꺼내어 배열의 뒤쪽부터 넣는다. 힙 트리의 가장 뒤에 있는 원소를 빈 루트 노드에 넣고 다시 힙 트리를 구성한다. → 반복

트리 아래에서 위로 각 원소들을 최대값 힙 조건에 맞게 정리한 후, 루트에 있는 값을 옮기며 정렬하는 방식

- O(NlogN)

### 퀵

피벗을 정하며 피벗보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 위치시킨 뒤 왼쪽과 오른쪽 수 들을 다시 각각의 피벗으로 나누어 리스트 크기가 1이 될 때 까지 정렬하는 방식

![image](https://user-images.githubusercontent.com/70561950/179021538-9127f957-a6e3-4d97-a462-f5b384a2c21a.png)

- 최선 - O(NlogN) 
- 최악 -  O(N^2)

### 선택

배열에서 최소값을 찾아 맨 앞의 값과 위치를 바꾸며 정렬하는 방식

- O(N^2)
